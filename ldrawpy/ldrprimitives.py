#! /usr/bin/env python3
#
# Copyright (C) 2020  Michael Gale
# This file is part of the legocad python module.
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation
# files (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
# OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
# LDraw primitives

import hashlib
from functools import reduce
from typing import List, Tuple, Union, Optional
from dataclasses import dataclass, field  # IMPORTED dataclass and field

# Explicit imports from toolbox
from toolbox import Vector, Matrix, Identity, euler_to_rot_matrix, safe_vector

# Explicit imports from .ldrhelpers (relative import within the package)
from .ldrhelpers import vector_str, mat_str, quantize
from .constants import LDR_DEF_COLOUR


@dataclass(eq=False)  # eq=False because we provide a custom __eq__
class LDRAttrib:
    # __slots__ = ["colour", "units", "loc", "matrix"] # Removed __slots__ for standard dataclass behavior
    # Can be added back with @dataclass(slots=True) in Py 3.10+
    # but requires careful handling of default_factory with slots.

    colour: int = LDR_DEF_COLOUR
    units: str = "ldu"
    # For mutable default types, use default_factory
    loc: Vector = field(default_factory=lambda: Vector(0, 0, 0))
    matrix: Matrix = field(default_factory=Identity)

    # The __init__ method is automatically generated by @dataclass.
    # We can add a __post_init__ if needed for validation or complex initialization.
    # For this class, ensure 'colour' is int after initialization if it can be passed as other types.
    def __post_init__(self):
        self.colour = int(self.colour)  # Ensure colour is an int

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, self.__class__):
            return NotImplemented
        # Custom __eq__ to use almost_same_as for Vector and Matrix
        return (
            self.colour == other.colour
            and self.units == other.units  # Added units comparison for completeness
            and self.loc.almost_same_as(other.loc)  # type: ignore
            and self.matrix.is_almost_same_as(other.matrix)
        )  # type: ignore

    def copy(self) -> "LDRAttrib":
        # Dataclasses are typically immutable by convention, but if mutable,
        # this copy method ensures deep copies of loc and matrix if their .copy() is deep.
        # Using dataclasses.replace would be a shallow copy of these fields.
        new_loc = self.loc.copy() if hasattr(self.loc, "copy") else self.loc
        new_matrix = self.matrix.copy() if hasattr(self.matrix, "copy") else self.matrix

        return LDRAttrib(
            colour=self.colour, units=self.units, loc=new_loc, matrix=new_matrix
        )


class LDRLine:
    __slots__ = ["attrib", "p1", "p2"]
    attrib: LDRAttrib
    p1: Vector
    p2: Vector

    def __init__(self, colour: int = LDR_DEF_COLOUR, units: str = "ldu"):
        self.attrib = LDRAttrib(colour, units)
        self.p1 = Vector(0, 0, 0)
        self.p2 = Vector(0, 0, 0)

    def __str__(self) -> str:
        return (
            f"2 {self.attrib.colour} "
            f"{vector_str(self.p1, self.attrib)}"
            f"{vector_str(self.p2, self.attrib)}\n"
        )

    def translate(self, offset: Vector):
        self.p1 += offset
        self.p2 += offset

    def transform(self, matrix: Matrix):
        self.p1 = self.p1 * matrix
        self.p2 = self.p2 * matrix  # type: ignore


class LDRTriangle:
    __slots__ = ["attrib", "p1", "p2", "p3"]
    attrib: LDRAttrib
    p1: Vector
    p2: Vector
    p3: Vector

    def __init__(self, colour: int = LDR_DEF_COLOUR, units: str = "ldu"):
        self.attrib = LDRAttrib(colour, units)
        self.p1, self.p2, self.p3 = Vector(0, 0, 0), Vector(0, 0, 0), Vector(0, 0, 0)

    def __str__(self) -> str:
        return (
            f"3 {self.attrib.colour} "
            f"{vector_str(self.p1, self.attrib)}{vector_str(self.p2, self.attrib)}"
            f"{vector_str(self.p3, self.attrib)}\n"
        )

    def translate(self, offset: Vector):
        self.p1 += offset
        self.p2 += offset
        self.p3 += offset

    def transform(self, matrix: Matrix):
        self.p1 *= matrix
        self.p2 *= matrix
        self.p3 *= matrix  # type: ignore


class LDRQuad:
    __slots__ = ["attrib", "p1", "p2", "p3", "p4"]
    attrib: LDRAttrib
    p1: Vector
    p2: Vector
    p3: Vector
    p4: Vector

    def __init__(self, colour: int = LDR_DEF_COLOUR, units: str = "ldu"):
        self.attrib = LDRAttrib(colour, units)
        self.p1, self.p2, self.p3, self.p4 = (
            Vector(0, 0, 0),
            Vector(0, 0, 0),
            Vector(0, 0, 0),
            Vector(0, 0, 0),
        )

    def __str__(self) -> str:
        return (
            f"4 {self.attrib.colour} "
            f"{vector_str(self.p1, self.attrib)}{vector_str(self.p2, self.attrib)}"
            f"{vector_str(self.p3, self.attrib)}{vector_str(self.p4, self.attrib)}\n"
        )

    def translate(self, offset: Vector):
        self.p1 += offset
        self.p2 += offset
        self.p3 += offset
        self.p4 += offset

    def transform(self, matrix: Matrix):
        self.p1 *= matrix
        self.p2 *= matrix
        self.p3 *= matrix
        self.p4 *= matrix  # type: ignore


@dataclass(
    eq=False
)  # eq=False because LDRPart has custom __eq__ based on name and color only
class LDRPart:
    # __slots__ = ["attrib", "name", "wrapcallout"] # Consider removing or using @dataclass(slots=True) for Py3.10+
    name: str = ""
    wrapcallout: bool = False
    # LDRAttrib needs to be a field with a default_factory if it's mutable and part of the dataclass
    # Or, it's initialized in __post_init__ or passed to __init__
    # For simplicity, let's make it a regular attribute initialized in __init__ or __post_init__
    # if we want to control its creation more directly or pass specific color/units.

    # Option 1: Make attrib a dataclass field (requires LDRAttrib to be hashable if LDRPart is hashable, or use field(compare=False))
    # attrib: LDRAttrib = field(default_factory=LDRAttrib) # This would use default LDR_DEF_COLOUR

    # Option 2: Keep it as an instance variable set in __init__ if more control is needed,
    # but then LDRPart isn't a "pure" dataclass in its attribute definitions.
    # For now, let's try with it as a field and allow __init__ to override.
    colour: int = LDR_DEF_COLOUR  # Pass color/units to LDRPart, then create LDRAttrib
    units: str = "ldu"
    # Actual attrib will be created in __post_init__ from colour and units
    # Or, we can pass an LDRAttrib instance directly if desired.

    # Let's make attrib a non-init field that's setup in post_init
    # Or, better, allow it to be passed or created.
    # We will simplify LDRPart's __init__ by taking colour/units and then creating attrib.

    # For dataclass, declare fields that will be in the auto-generated __init__
    # If 'attrib' is the main way to hold color/units/loc/matrix, then it should be a field.
    # However, LDRPart often initializes with just color and name.

    # Let's stick to the original LDRPart structure for attributes for now and manually manage __init__
    # if converting fully to dataclass for LDRPart is too complex with its current methods.
    # The request was for LDRAttrib. I will keep LDRPart as a regular class for now.

    attrib: LDRAttrib  # This will be initialized
    # name: str # Declared by @dataclass if LDRPart becomes one
    # wrapcallout: bool # Declared by @dataclass if LDRPart becomes one

    def __init__(
        self,
        colour: int = LDR_DEF_COLOUR,
        name: Optional[str] = None,
        units: str = "ldu",
    ):
        self.attrib = LDRAttrib(colour, units)  # LDRAttrib is now a dataclass
        self.name = name if name is not None else ""
        self.wrapcallout = False

    def __str__(self) -> str:
        matrix_elements = []
        if hasattr(self.attrib.matrix, "rows") and self.attrib.matrix.rows:
            matrix_elements = [item for sublist in self.attrib.matrix.rows for item in sublist]  # type: ignore
        else:
            matrix_elements = [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0]
        tup_matrix_str = mat_str(tuple(matrix_elements))
        name_to_write = self.name
        if name_to_write:
            ext = name_to_write[-4:].lower()
            if not (ext == ".ldr" or ext == ".dat"):
                name_to_write += ".dat"
        else:
            name_to_write = "unknown.dat"
        s = (
            f"1 {self.attrib.colour} "
            f"{vector_str(self.attrib.loc, self.attrib)}"
            f"{tup_matrix_str}"
            f"{name_to_write}\n"
        )
        if self.wrapcallout and name_to_write.endswith(".ldr"):
            return f"0 !LPUB CALLOUT BEGIN\n{s}0 !LPUB CALLOUT END\n"
        return s

    def __eq__(self, other: object) -> bool:  # LDRPart's custom __eq__
        if not isinstance(other, self.__class__):
            return NotImplemented
        return self.name == other.name and self.attrib.colour == other.attrib.colour

    def copy(self) -> "LDRPart":
        p = LDRPart(colour=self.attrib.colour, name=self.name, units=self.attrib.units)
        p.wrapcallout = self.wrapcallout
        # Since LDRAttrib.copy() exists and handles its fields:
        p.attrib = self.attrib.copy()
        return p

    def sha1hash(self) -> str:
        shash = hashlib.sha1()
        shash.update(bytes(str(self), encoding="utf8"))
        return shash.hexdigest()

    def is_identical(self, other: "LDRPart") -> bool:
        return (
            self.name == other.name and self.attrib == other.attrib
        )  # Relies on LDRAttrib.__eq__

    def is_same(
        self,
        other: "LDRPart",
        ignore_location: bool = False,
        ignore_colour: bool = False,
        exact: bool = False,
    ) -> bool:
        if self.name != other.name:
            return False
        if exact:
            return self.is_identical(other)
        if not ignore_colour and self.attrib.colour != other.attrib.colour:
            return False
        if not ignore_location and not self.attrib.loc.almost_same_as(other.attrib.loc):
            return False  # type: ignore
        return True

    def is_coaligned(self, other: "LDRPart") -> bool:
        try:
            v1 = self.attrib.loc * self.attrib.matrix
            v2 = other.attrib.loc * other.attrib.matrix  # type: ignore
            if hasattr(v1, "is_colinear_with"):
                return v1.is_colinear_with(v2) == 2  # type: ignore
        except AttributeError:
            pass
        return False

    def change_colour(self, to_colour: int):
        self.attrib.colour = to_colour

    def set_rotation(self, angle: Union[Tuple[float, float, float], Vector]):
        self.attrib.matrix = euler_to_rot_matrix(angle)

    def move_to(self, pos: Union[Tuple[float, float, float], Vector]):
        self.attrib.loc = safe_vector(pos)

    def move_by(self, offset: Union[Tuple[float, float, float], Vector]):
        self.attrib.loc += safe_vector(offset)  # type: ignore

    def rotate_by(self, angle: Union[Tuple[float, float, float], Vector]):
        rm = euler_to_rot_matrix(angle)
        self.attrib.loc = rm * self.attrib.loc  # type: ignore
        self.attrib.matrix = rm * self.attrib.matrix  # type: ignore

    def transform(self, matrix: Matrix = Identity(), offset: Vector = Vector(0, 0, 0)):
        self.attrib.loc = matrix * self.attrib.loc + offset  # type: ignore
        self.attrib.matrix = matrix * self.attrib.matrix  # type: ignore

    def from_str(self, s: str) -> Optional["LDRPart"]:
        sl = s.strip().lower().split()
        if not len(sl) >= 14:
            return None
        try:
            if int(sl[0]) != 1:
                return None
            self.attrib.colour = int(sl[1])
            self.attrib.loc.x = quantize(sl[2])
            self.attrib.loc.y = quantize(sl[3])
            self.attrib.loc.z = quantize(sl[4])
            m = [quantize(sl[i]) for i in range(5, 14)]
            self.attrib.matrix = Matrix([m[0:3], m[3:6], m[6:9]])
            self.name = " ".join(sl[14:]).replace(".dat", "") if sl[14:] else ""
        except (ValueError, IndexError):
            return None
        return self

    @staticmethod
    def translate_from_str(
        s: str, o_val: Union[Tuple[float, float, float], Vector]
    ) -> str:
        o = safe_vector(o_val)
        p = LDRPart()
        if p.from_str(s) is None:
            return ""
        p.attrib.loc += o
        p.wrapcallout = False
        return str(p)

    @staticmethod
    def transform_from_str(
        s: str,
        mx_val: Optional[Matrix] = None,
        o_val: Optional[Union[Tuple[float, float, float], Vector]] = None,
        c: Optional[int] = None,
    ) -> str:
        mx = mx_val if mx_val is not None else Identity()
        o = safe_vector(o_val) if o_val is not None else Vector(0, 0, 0)
        p = LDRPart()
        if p.from_str(s) is None:
            return ""
        p.attrib.loc = mx * p.attrib.loc + o  # type: ignore
        p.attrib.matrix = mx * p.attrib.matrix  # type: ignore
        p.wrapcallout = False
        if c is not None:
            p.attrib.colour = c
        return str(p)


@dataclass(
    eq=False
)  # Providing custom __str__, no need for auto __eq__ if not comparing headers
class LDRHeader:
    title: str = ""
    file: str = ""  # Corresponds to "0 FILE "
    name: str = ""  # Corresponds to "0 Name: "
    author: str = ""

    def __str__(self) -> str:
        header_lines = []
        if self.title:
            header_lines.append(f"0 {self.title}")
        if self.file:
            header_lines.append(f"0 FILE {self.file}")
        if self.name:
            header_lines.append(f"0 Name: {self.name}")
        if self.author:
            header_lines.append(f"0 Author: {self.author}")
        return "\n".join(header_lines) + "\n" if header_lines else ""
